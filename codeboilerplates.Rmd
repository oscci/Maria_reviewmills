---
title: "Coding for review mills"
author: "Dorothy Bishop"
date: "2025-08-09"
output: html_document
---
last revision 28th Sept

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
require(here)
require(TSDT) #for unfactor function ?may not be used

require(stringr)
require(ggpubr) #organise plots - not currently used
library(reshape) #for melt function for geom
library("xlsx") #read and write xlsx files

```

Main files that we need for this:
indexdf is the original file from Maria that has one row per review, with biblio information about the article, wayback link to the reviews, and also lists the reviewer, original boilerplate codes, PMIDs and whether they were cited.

We prune it so we just have the required columns

Then we change the names of reviewers to match PMID format

There is option to remove reviewers who did just one review

Finally we make a list of the reviewers and count how many reviews each did.

```{r readindexdf}

indexdf <- read.xlsx("Data set 28 Sep- Gaming the peer review system.xlsx",sheetIndex=1)


#we'll cut out unwanted columns
wantcols <- c('ID','REVIEWER','REVIEWED.ARTICLE.JOURNAL','REVIEWED.ARTICLE.PUBLISHER','REVIEWED.ARTICLE.DOI',
              'Stock.phrases.included','PMIDs.mentioned','PMID.in.final.version.refs','coerced..9.for.resisted.','comparison.rev','Nrev.in.target.set')
indexdf<-indexdf[,wantcols]
names(indexdf)<-c('ID','Reviewer','Journal','Publisher','DOI','Boilerplate','PMID','cited', 'coerced','comparison.rev','NrevThisArticle')
#remove blank row
w<-which(is.na(indexdf$Reviewer))
if(length(w)>0){
indexdf<-indexdf[-w,]}

w<-which(is.numeric(indexdf$ID))
if(length(w)>0){
indexdf<-indexdf[-w,]}


indexdf$Reviewer<-case_match(indexdf$Reviewer, "Andrea Giannini"  ~ "Giannini A",
                        "Ottavia D'Oria"  ~ "D'Oria O",
                         "Giorgio Bogani" ~ "Bogani G",
                        "Violante Di Donato" ~"Di Donato V",
                        "Antonio Simone Laganà" ~ "Laganà AS",
                        "Fabrizio Signore" ~ "Signore F",
                        "Ilaria Cuccu" ~ "Cuccu I",
                        "Silvia Ganduscio" ~ "Ganduscio S",
                        "Tullio Golia D'Augè" ~ "D'Augè TG",
                        "Felice Sorrentino"~"Sorrentino F",
                        "Andrea Etrusco" ~ "Etrusco A",
                        "Veronica Lumia" ~"Lumia V",
                        "Gaetano Riemma" ~"Riemma G",
                        "Doriana Lucchese"~"Lucchese D", 
                        "Giuseppe Gullo" ~"Gullo G",
                        "Salvatore Insinga" ~ "Insinga S",
                        "Pietro Serra" ~ "Serra P",
                        "Alessandra Lopez" ~ "Lopez A",
                       .default = "X_Anon")
allrevstable<-table(indexdf$Reviewer)
fulldf<-indexdf
Nrevbyarticle <- table(fulldf$NrevThisArticle)
w<-which(fulldf$PMID=='none')
length(w) #These are reviews with no coercive citation (PMID or other)

#Table of publishers/journals
oneperarticle<-fulldf[fulldf$NrevThisArticle==1,]

oneperarticle$journal2<-oneperarticle$Journal
allj<-unique(oneperarticle$Journal)
for(i in 1:length(allj)){
  w<-which(oneperarticle$Journal==allj[i])
  if(length(w)<3){
    oneperarticle$journal2[w]<-paste0(oneperarticle$Publisher[w],": Other")
  }
    if(length(w)>2){
    oneperarticle$journal2[w]<-paste0(oneperarticle$Publisher[w],": ",allj[i])
  }
}
pubjtab<-table(oneperarticle$journal2)
write.csv(pubjtab,'pubjtab.csv')

############ select for quantitative analysis ########################
#Select group for quantitative analysis (indexdf) by removing solos
#Remove reviewers with just one review if removesolo =1
removesolo<-1
if(removesolo==1){
  solorevs<-c('Lopez A','Lucchese D','Signore F','Sorrentino F','Riemma G','Serra P','Insigna S','Ganduscio S','Lumia V', 'Insinga S')
  
  #solorevs<-c('Alessandra Lopez','Doriana Lucchese', 'Fabrizio Signore', 'Felice Sorrentino','Gaetano Riemma','Pietro Serra','Salvatore Insinga','Silvia Ganduscio','Veronica Lumia')
 
  for (s in 1:length(solorevs)){
    w<-which(indexdf$Reviewer == solorevs[s])
    if(length(w)>0){
    indexdf<-indexdf[-w,]
    }
  }
}

myrevs<-unique(indexdf$Reviewer)

nrev<-length(myrevs)
trev <- table(indexdf$Reviewer)
Nbyrev<-as.vector(trev) #This has the N reviews done by each reviewer, in same order as codetab

tcon<-as.data.frame.matrix(table(indexdf$comparison.rev,indexdf$Reviewer))
write.xlsx(tcon,'Nconrevs.xlsx')
w<-which(row.names(tcon)=='n/a') #find row for those without comparison
#remove anons which are in last col
noncon<-tcon[w,1:(ncol(tcon)-1)]
allrev<-Nbyrev[1:(length(Nbyrev)-1)]
propcon<-(allrev-noncon)/allrev
sum(noncon)/sum(allrev) #total proportion of reviews with comparison

```

Next file is the one with a line for each comment in each review, all stacked together for the target set.
This is some version of allrevs, and is xlsx format.
We read the first sheet as coded_df

The second sheet has the boilerplate codes defined, and includes columns for the original letter codes and the new codes.
The new codes for many sections have several numbered subtypes. 
We can read those in to get counts for subtypes, but later we drop the number so we have coarse codes.



```{r recodebigfile_and_boiler}
coded_df <- read.xlsx('allrevs_280925.xlsx',sheetName="Reviews")
boilercode<-read.xlsx('allrevs_280925.xlsx',sheetName="boiler10")
NRcases<-nrow(coded_df) #we'll be appending to this so need to keep N for just R coded
#We'll append the control revs to coded_df

con_df<-read.xlsx("Comparison data/all_control_revs_coded_28Sep2025.xlsx",sheetName="Reviews")
#NB there are blanks in boilercode; select just rows with codes

#to append con data need to match column names. Easiest is to make a duplicate df and paste in the cols we have

temp<-coded_df[1:nrow(con_df),] #dummy to hold data
for (i in 1:ncol(coded_df)){
  w<-which(names(con_df)==names(coded_df)[i])
  if(length(w)>0){
  temp[,w]<-con_df[,w]
  }
  if(length(w)==0){
  temp[,i]<-NA
  }
}
  
#bolt on cons after creating a col with group
coded_df$group<-'R'
temp$group<-'C'
coded_df<-rbind(coded_df,temp)


boileromit<-which(is.na(boilercode$orig.code)) 
allboiler<-1:nrow(boilercode)
if(length(boileromit>0)){
boilerrows<-allboiler[-boileromit]}
coded_df$nucode<-NA
oldcodes<-unique(boilercode$orig.code)
newcodes<-unique(boilercode$subtype)
for (i in boilerrows){
  coded_df$nucode[w]<-boilercode$subtype[i]
  w<-which(coded_df$final[1:NRcases]==boilercode$orig.code[i])
  #NOTE : we are counting only for the R reviews!
  boilercode$N.occurrence[i]<- length(w)

}
  
write.xlsx(boilercode,'boilerwithN.xlsx',row.names=F)

#Same as original boilercode but has N occurences added. 

#Checking changes made by RA to original: do cross tabulation
# write.xlsx(boilercode,'boilercode.xlsx')
# t<-table(coded_df$code1,coded_df$codeRA)
# write.csv(t,'codetab.csv')


#remove blank rows from big file with all coded reports (coded_df)
w<-which(is.na(coded_df$ID))
coded_df<-coded_df[-w,]
allcodes<-unique(coded_df$nucode)

```


```{r addreviewerstocodeddf}
#Need to add column specifying reviewer for each ID
coded_df$Reviewer<-NA
coded_df$numID<-as.integer(substring(coded_df$ID,2,4)) #ID for this review; we need to find each line with this number and add the reviewer
#But exclude the Controls!
coded_df$numID[coded_df$group=="C"]<-NA

for(i in 1:nrow(indexdf)){
  thisnum<-indexdf$ID[i]
  w<-which(coded_df$numID==thisnum) #lines that below to this review
  coded_df$Reviewer[w]<-indexdf$Reviewer[i]
}

coded_df$coarsecode<-substr(coded_df$nucode,1,1) #just the initial letter for coarsecode

cittab<-table(coded_df$citationtype)
#citation type is P for PMID, D for DOI, T for title and C for citation (with authors).
#the number indicates the number of coerced citations. 

btab<-as.data.frame.matrix(table(coded_df$ID,coded_df$final))
w<-which(btab$D==0)

codetab<-as.data.frame.matrix(table(coded_df$Reviewer,coded_df$coarsecode))



codetab2<-codetab
for (r in 1:nrow(codetab)){
  codetab2[r,]<-codetab[r,]/Nbyrev[r] #N mentions of code per review
}  
```


```{r domelt}
mytab2<-as.matrix(codetab2)  #need matrix format for melt

# Transform the matrix in long format
dfm<- melt(mytab2)
revnames<-levels(dfm$X1)

colnames(dfm)[1:3] <- c("Reviewer", "code","N_per_review")
#dfm$Reviewer is a factor.  We should be able to change levels to anonymise
nl<-length(levels(dfm$Reviewer))
levels(dfm$Reviewer) <- c(paste('Reviewer',1:(nl-1)),'Anon')
revlabels<-paste0(levels(dfm$Reviewer)," \n(",Nbyrev," reviews)")


```


```{r revheatmap}
# Plot heatmap with values
# remove categories for unique codes
# w<-c(which(dfm$code=='X1'),which(dfm$code=='X2'),which(dfm$code=='X3'))
# if(length(w)>0){
# dfm<-dfm[-w,]}
#
g <- ggplot(dfm, aes(y = Reviewer, x = code, fill = N_per_review, color=value)) +
  geom_tile(color = "white") + # Create heatmap
  #geom_text(color = "black", size = 3)+ # Add text labels
  scale_fill_gradient(low = "beige", high = "darkblue") + # Set color gradient
  theme_minimal() + # Set theme
  labs(x = "", y = "") + 
 # Labels
   theme(axis.text.x = element_text(angle = 90, hjust = 1,size=6))+
  theme_bw()
  
ggsave("heatmap_boilercodes.tif", dpi=300, width = 7, height = 3)

```

Analysis of PMIDs now appended here

```{r pmidread}


pmids <- read.xlsx('pmids/PMID_au_list_Sep27.xlsx',sheetIndex=1)

#pmids$PMID <-str_trim(pmids$PMID) #(not needed here but useful if strings have preceding or final blank space
#pmids$Authors <- sub(';',',',pmids$Authors)

namechange<-read.csv('name convert.csv') #hand crafted! may need to add
for (i in 1:nrow(namechange)){
  pmids$Authors<- sub(namechange$convert.from[i],namechange$convert.to[i],pmids$Authors) 

}
```
Get a list of all the authors of these articles.
Means splitting col 2 of the pmids; these are comma separated.
NB some have semicolon before an organisation

```{r getallaus}
dfauth<-data.frame(matrix(NA,nrow=2000,ncol=2))
names(dfauth)<-c('PMID','Author')

pmids$Authors <- sub(';',',',pmids$Authors) #change semicolons to commas
thisrow<-0
for(i in 1:nrow(pmids)){
    s<-unlist(str_split_1(pmids$Authors[i],","))
    for (r in 1:length(s)){
      dfauth$PMID[(thisrow+r)]<-pmids$PMID[i]
      dfauth$Author[(thisrow+r)]<-trimws(s[r],whitespace="[ .]") #remove stop as well as space
    }
    thisrow<-thisrow+length(s)
    
}
w<-which(dfauth$PMID>0)
if(length(w)>0){
dfauth<-dfauth[w,]#remove blanks
}
#double check for dodgy names
for (i in 1:nrow(namechange)){
  dfauth$Author<- sub(namechange$convert.from[i],namechange$convert.to[i],dfauth$Author) 

}
autab<-table(dfauth$Author)
autab<-autab[order(autab,decreasing=T)]

autab[1:20]
mauthor<-data.frame(autab)
write.xlsx(dfauth,"Individual_authors_PMID.xlsx") #scrutinise this in case any more duplicate names
write.xlsx(mauthor,"Individual_author_counts.xlsx")

```



```{r pmidtable}

mytab<-data.frame(matrix(0,nrow=nrow(pmids),ncol=(1+length(myrevs))))

#Remarkably convoluted to get the N reviews for each reviewer in the right order! 
#This seems to work without needing hard coding.
revcounts<-as.data.frame.matrix(t(table(indexdf$Reviewer)))
allrevs<-names(revcounts) #revs in the order we can use for creating name with count
nrevs<-length(allrevs)    
names(mytab)<-c('PMID',allrevs)
mytab$PMID<-pmids$PMID
revlabels<-paste0(allrevs," \n(",Nbyrev," reviews)")

pmidlist<-as.vector(pmids$PMID)
 for (i in 1:length(pmidlist)){
  for (a in 1:length(allrevs)){
  myset <- indexdf$PMID[indexdf$Reviewer==allrevs[a]]
    for (s in 1:length(myset)){
    g <- grep(pmidlist[i],myset[s])
    if(length(g)>0)
      {mytab[i,(a+1)]<-mytab[i,(a+1)]+1}
    }
  }
 }


```


```{r formatformelt}

thistab<-mytab #for PMIDS
#add the N times PMID was cited in brackets after PMID
thistab$coerced<-0
thistab$cited<-0

for (i in 1:nrow(indexdf)){
  for(j in 1:length(pmidlist)){
      g <- grep(pmidlist[j],indexdf$cited[i])
        if(length(g)>0)  {thistab$cited[j]<-thistab$cited[j]+1}   
      h <- grep(pmidlist[j],indexdf$PMID[i])
      if(length(h)>0)  {thistab$coerced[j]<-thistab$coerced[j]+1}
  }
}
thistab$PMID<-paste0(thistab$PMID," (",thistab$cited,")") #incorporate cite count in PMID

thistab<-thistab[order(thistab$PMID),]

plot(jitter(thistab$coerced),jitter(thistab$cited))

# nc<-ncol(thistab) #then delete citecount column
# thistab<-thistab[,-nc]

mytab2<-as.matrix(thistab[,2:(nrevs+1)])  #need matrix format for melt


```

```{r domelt}
# Transform the matrix in long format
dfmp<- melt(mytab2)
dfmp$X1<-thistab[,1] #copies labels into 1st col


colnames(dfmp) <- c("x", "Reviewer","value")
dfmp$isauthor<-0 #add new column
#we'll now add a column that indicates if Reviewer was an author on that PMID
for (i in 1:nrow(dfmp)){
  thisrev<-dfmp$Reviewer[i] #this has the short reviewer names from PMID
  thisp <- dfmp$x[i]
  plen<-length(thisp)
  s<-unlist(str_split_1(thisp," "))[[1]] #remove stuff after blank to get PMID
  w<-which(dfauth$PMID == s)
  theseauths<-dfauth$Author[w]
  ww<-which(theseauths==thisrev)
  if(length(ww)>0){
  dfmp$isauthor[i]<-1
  }

}
  #change isauthor to a colour
dfmp$marker<-''
dfmp$marker[dfmp$isauthor==1]<-'*'

dfmp$valuex<-paste0(dfmp$value,dfmp$marker)

#dfmp$Reviewer is a factor.  We should be able to change levels to anonymise
nl<-length(levels(dfmp$Reviewer))
levels(dfmp$Reviewer) <- c(paste('Reviewer',1:(nl-1)),'Anon')
revlabels<-paste0(levels(dfmp$Reviewer)," \n(",Nbyrev," reviews)")
names(dfmp)[3]<-'Count'
dfmp$Count.old<-dfmp$Count
dfmp$Count[dfmp$Count>5]<-5  #Truncating the count so 5+ becomes 5

#gp + annotate("text", x = 240, y = 7.1, label = "+")


```



```{r revheatmap}
# Plot heatmap with values -originalwith reviewers on x axis


gp <- ggplot(dfmp, aes(y = Reviewer, x = x, fill = Count, label = marker,color=color)) +
  geom_tile(color = "white") + # Create heatmap
  geom_text(color = "black", size = 3)+ # Add text labels
  scale_fill_gradient(low = "beige", high = "blue") + # Set color gradient
  theme_minimal() + # Set theme
  labs(x = "Articles with citation request", y = "") + 
 scale_y_discrete(labels=revlabels)+ # Labels
   theme_bw()+
  theme(axis.text.x = element_blank())

ggsave("heatmap_PMIDs.tif", dpi=300, width = 7, height = 4)


```

NB to make top of scale say 5+, I just opened this in preview and then added annotation!

```{r sundrystats}
jtab<-table(indexdf$Journal,indexdf$Publisher)
write.xlsx(as.data.frame.matrix(jtab),'JournalPublist.xlsx',row.names=T)
pubtab<-table(indexdf$Publisher)
pubptab<-prop.table(pubtab)
pubptab

#Proportion of articles with successful coercions
coercedtab<-table(fulldf$coerced)

```




               




