---
title: "Code_pmids"
author: "Dorothy Bishop"
date: "2025-08-09"
output: html_document
---

Reads the list of PMIDs so that can see when a specific reviewer is a coauthor and include this in heatmap
I found it was possible to get all authors by a search of Pubmed with a long list of PMIDs separated by OR. Then export as csv.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
require(here)
require(TSDT) #for unfactor function ?may not be used

require(stringr)
require(ggpubr) #organise plots - not currently used
library(reshape) #for melt function for geom
library("xlsx") #read and write xlsx files

```


A lot of problems could be overcome if at the outset I changed the reviewer names in the df file so they match those in the PMIDs file.  I'll do that, because at present it is not good to have hard coding.

```{r readmaindf}

df <- read.xlsx('Data set 30 Aug.xlsx',sheetIndex=1)
saveRDS(df, file = "dfimported30Aug.rds")
#we'll cut out unwanted columns
wantcols <- c('REVIEWER','REVIEWED.ARTICLE.PUBLISHER','REVIEWED.ARTICLE.DOI',
              'Stock.phrases.included','PMIDs.mentioned','PMID.in.final.version.refs')
df<-df[,wantcols]
names(df)<-c('Reviewer','Publisher','DOI','Boilerplate','PMID','cited')
#remove blank row
w<-which(is.na(df$Reviewer))
df<-df[-w,]

```

Decide which reviewers to include; need to have all the 'reviewer' cases together as Anon.
```{r recodereviewer}

g <- grep('Reviewer',df$Reviewer) #find reviewers with 'Reviewer' in the name
df$Reviewer[g]<-'_Anon'
g <- grep('Anon',df$Reviewer)
df$Reviewer[g]<-'_Anon'
trev<-table(df$Reviewer)

solos<-names(which(trev==1)) #those with just report will be recoded 'other'
w<-which(df$Reviewer %in% solos)
df$Reviewer[w]<-'X_other'

myrevs<-unique(df$Reviewer)
myrevs<-myrevs[c(1:5,7:9,6,10)] #reorder determined by eye to put Anon and X_other at the end

nrev<-length(myrevs)
```




```{r pmidread}


pmids <- read.csv('PMIDS_with_aus.csv')
pmids<-pmids[,c(1,3)] #only need PMID and Authors
#pmids$PMID <-str_trim(pmids$PMID) #(not needed here but useful if strings have preceding or final blank space


```


Would be nice to have a list of all the authors of these articles.
Means splitting col 2 of the pmids; these are comma separated.

```{r getallaus}
dfauth<-data.frame(matrix(NA,nrow=2000,ncol=2))
names(dfauth)<-c('PMID','Author')
thisrow<-0
for(i in 1:nrow(pmids)){
    s<-unlist(str_split_1(pmids$Authors[i],","))
    for (r in 1:length(s)){
      dfauth$PMID[(thisrow+r)]<-pmids$PMID[i]
      dfauth$Author[(thisrow+r)]<-trimws(s[r],whitespace="[ .]") #remove stop as well as space
    }
    thisrow<-thisrow+length(s)
    
}
w<-which(dfauth$PMID>0)
dfauth<-dfauth[w,]#remove blanks

autab<-table(dfauth$Author)
autab<-autab[order(autab,decreasing=T)]

autab[1:20]
mauthor<-data.frame(autab)
write.xlsx(dfauth,"Individual_authors_PMID.xlsx")
write.xlsx(mauthor,"Individual_author_counts.xlsx")

allrevs<- c(names(autab[c(2,7,5,4,1,24,26,109)]),'X_other','_Anon')
#Had to do this manually because names formatted differently in PMID and in df;

```






```{r pmidtable}

mytab<-data.frame(matrix(0,nrow=nrow(pmids),ncol=(1+length(allrevs))))
names(mytab)<-c('PMID',allrevs)
mytab$PMID<-pmids$PMID
pmidlist<-pmids$PMID


 for (i in 1:length(pmidlist)){
  for (a in 1:length(allrevs)){
  myset <- df$PMID[df$Reviewer==myrevs[a]] #myrevs has orig names
    for (s in 1:length(myset)){
    g <- grep(pmidlist[i],myset[s])
    if(length(g)>0)
      {mytab[i,(a+1)]<-mytab[i,(a+1)]+1}
    }
  }
 }


```



```{r trygeomtile}

thistab<-mytab #for PMIDS
#add the N times PMID was cited in brackets after PMID
thistab$citecount<-0
thistab$trycoerce<-0
for (i in 1:nrow(df)){
  for(j in 1:length(pmidlist)){
      g <- grep(pmidlist[j],df$cited[i])
        if(length(g)>0)  {thistab$citecount[j]<-thistab$citecount[j]+1}   
      h <- grep(pmidlist[j],df$PMID[i])
      if(length(h)>0)  {thistab$trycoerce[j]<-thistab$trycoerce[j]+1}
  }
}
thistab$PMID<-paste0(thistab$PMID," (",thistab$citecount,")") #incorporate cite count in PMID

plot(jitter(thistab$trycoerce),jitter(thistab$citecount))

# nc<-ncol(thistab) #then delete citecount column
# thistab<-thistab[,-nc]
nrevs<-length(allrevs)
mytab2<-as.matrix(thistab[,2:(nrevs+1)])

#Nightmare getting the names aligned, given different names in the pmid and df files. 
revorder<-c(3,7,5,9,4,6,8,2,10,1)
revcount<-as.vector(table(df$Reviewer))[revorder]
                    
revlabels<-paste0(allrevs," \n(",revcount," reviews)")


# Transform the matrix in long format
dfm<- melt(mytab2)
dfm$X1<-thistab[,1] #copies labels into 1st col


colnames(dfm) <- c("x", "Reviewer","value")
dfm$isauthor<-0 #add new column
#we'll now add a column that indicates if Reviewer was an author on that PMID
for (i in 1:nrow(dfm)){
  thisrev<-dfm$Reviewer[i] #this has the short reviewer names from PMID
  thisp <- dfm$x[i]
  plen<-length(thisp)
  s<-unlist(str_split_1(thisp," "))[[1]] #remove stuff after blank to get PMID
  w<-which(dfauth$PMID == s)
  theseauths<-dfauth$Author[w]
  ww<-which(theseauths==thisrev)
  if(length(ww)>0){
  dfm$isauthor[i]<-1
  }

}
  #change isauthor to a colour
dfm$marker<-''
dfm$marker[dfm$isauthor==1]<-'*'

dfm$valuex<-paste0(dfm$value,dfm$marker)

```

```{r makemap}


# Plot heatmap with values
g <- ggplot(dfm, aes(x = Reviewer, y = x, fill = value, label = valuex,color=color)) +
  geom_tile(color = "white") + # Create heatmap
  geom_text(color = "black", size = 1)+ # Add text labels
  scale_fill_gradient(low = "white", high = "cornflowerblue") + # Set color gradient
  theme_minimal() + # Set theme
  labs(x = "", y = "") + 
 scale_x_discrete(labels=revlabels)+ # Labels
  theme(legend.position = "none")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size=6))+
  theme(axis.text.y = element_text(size=6))

```
