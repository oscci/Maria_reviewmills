---
title: "Code_pmids"
author: "Dorothy Bishop"
date: "2025-08-09"
output: html_document
---

Reads the list of PMIDs so that can see when a specific reviewer is a coauthor and include this in heatmap
I found it was possible to get all authors by a search of Pubmed with a long list of PMIDs separated by OR. Then export as csv.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(tidyverse)
require(here)
require(TSDT) #for unfactor function ?may not be used

require(stringr)
require(ggpubr) #organise plots - not currently used
library(reshape) #for melt function for geom
library("xlsx") #read and write xlsx files

```


A lot of problems could be overcome if at the outset I changed the reviewer names in the df file so they match those in the PMIDs file.  I'll do that, because at present it is not good to have hard coding to align these. 

```{r readmaindf}

df <- read.xlsx('Data set 30 Aug.xlsx',sheetIndex=1)
saveRDS(df, file = "dfimported30Aug.rds")
#we'll cut out unwanted columns
wantcols <- c('REVIEWER','REVIEWED.ARTICLE.PUBLISHER','REVIEWED.ARTICLE.DOI',
              'Stock.phrases.included','PMIDs.mentioned','PMID.in.final.version.refs')
df<-df[,wantcols]
names(df)<-c('Reviewer','Publisher','DOI','Boilerplate','PMID','cited')
#remove blank row
w<-which(is.na(df$Reviewer))
df<-df[-w,]

#Recode names in df file to be same as in PMID file; can also make rare cases 'other';

df$Reviewer<-case_match(df$Reviewer, "Andrea Giannini"  ~ "Giannini A",
                        "Ottavia D'Oria"  ~ "D'Oria O",
                         "Giorgio Bogani" ~ "Bogani G",
                        "Violante Di Donato" ~"Di Donato V",
                        "Antonio Simone Laganà" ~ "Laganà AS",
                        "Fabrizio Signore" ~ "Signore F",
                        "Ilaria Cuccu" ~ "Cuccu I",
                         "Silvia Ganduscio" ~ "Ganduscio S",
                        "Tullio Golia D'Augè" ~ "D'Augè TG",
                        "Felice Sorrentino"~"Sorrentino F",
                        "Andrea Etrusco" ~ "Etrusco A",
                        "VERONICA LUMIA" ~"Lumia V",
                        "Gaetano Riemma" ~"Riemma G",
                        "Doriana Lucchese "~"Lucchese D", #NB space after name
                       .default = "X_Anon")
table(df$Reviewer)

#Remove reviewers with just one review
solorevs<-c('Sorrentino F','Signore F','Riemma G','Lumia V','Lucchese D','Ganduscio S')
for (s in 1:length(solorevs)){
  w<-which(df$Reviewer == solorevs[s])
  df<-df[-w,]
}
```

Decide which reviewers to include; need to have all the 'reviewer' cases together as Anon.
```{r recodereviewer}


trev<-table(df$Reviewer)
makeother<-0
if (makeother==1){
solos<-names(which(trev==1)) #those with just report will be recoded 'other'
w<-which(df$Reviewer %in% solos)
df$Reviewer[w]<-'X_other'
}

myrevs<-unique(df$Reviewer)

nrev<-length(myrevs)
```




```{r pmidread}


pmids <- read.csv('PMIDS_with_aus.csv')
pmids<-pmids[,c(1,3)] #only need PMID and Authors
#pmids$PMID <-str_trim(pmids$PMID) #(not needed here but useful if strings have preceding or final blank space
pmids$Authors <- sub(';',',',pmids$Authors)

namechange<-read.csv('name convert.csv') #hand crafted! may need to add
for (i in 1:nrow(namechange)){
  pmids$Authors<- sub(namechange$convert.from[i],namechange$convert.to[i],pmids$Authors) 

}
```


Would be nice to have a list of all the authors of these articles.
Means splitting col 2 of the pmids; these are comma separated.
NB some have semicolon before an organisation

```{r getallaus}
dfauth<-data.frame(matrix(NA,nrow=2000,ncol=2))
names(dfauth)<-c('PMID','Author')

pmids$Authors <- sub(';',',',pmids$Authors) #change semicolons to commas
thisrow<-0
for(i in 1:nrow(pmids)){
    s<-unlist(str_split_1(pmids$Authors[i],","))
    for (r in 1:length(s)){
      dfauth$PMID[(thisrow+r)]<-pmids$PMID[i]
      dfauth$Author[(thisrow+r)]<-trimws(s[r],whitespace="[ .]") #remove stop as well as space
    }
    thisrow<-thisrow+length(s)
    
}
w<-which(dfauth$PMID>0)
dfauth<-dfauth[w,]#remove blanks

autab<-table(dfauth$Author)
autab<-autab[order(autab,decreasing=T)]

autab[1:20]
mauthor<-data.frame(autab)
write.xlsx(dfauth,"Individual_authors_PMID.xlsx")
write.xlsx(mauthor,"Individual_author_counts.xlsx")

```






```{r pmidtable}

mytab<-data.frame(matrix(0,nrow=nrow(pmids),ncol=(1+length(myrevs))))

mytab$PMID<-pmids$PMID
pmidlist<-pmids$PMID

#Remarkably convoluted to get the N reviews for each reviewer in the right order! 
#This seems to work without needing hard coding.
revcount<-as.data.frame.matrix(t(table(df$Reviewer)))
allrevs<-names(revcount) #revs in the order we can use for creating name with count
nrevs<-length(allrevs)    
names(mytab)<-c('PMID',allrevs)
mytab$PMID<-pmids$PMID
revlabels<-paste0(allrevs," \n(",revcount[1,]," reviews)")


 for (i in 1:length(pmidlist)){
  for (a in 1:length(allrevs)){
  myset <- df$PMID[df$Reviewer==allrevs[a]]
    for (s in 1:length(myset)){
    g <- grep(pmidlist[i],myset[s])
    if(length(g)>0)
      {mytab[i,(a+1)]<-mytab[i,(a+1)]+1}
    }
  }
 }


```



```{r formatformelt}

thistab<-mytab #for PMIDS
#add the N times PMID was cited in brackets after PMID
thistab$coerced<-0
thistab$cited<-0

for (i in 1:nrow(df)){
  for(j in 1:length(pmidlist)){
      g <- grep(pmidlist[j],df$cited[i])
        if(length(g)>0)  {thistab$cited[j]<-thistab$cited[j]+1}   
      h <- grep(pmidlist[j],df$PMID[i])
      if(length(h)>0)  {thistab$coerced[j]<-thistab$coerced[j]+1}
  }
}
thistab$PMID<-paste0(thistab$PMID," (",thistab$cited,")") #incorporate cite count in PMID

thistab<-thistab[order(thistab$PMID),]

plot(jitter(thistab$coerced),jitter(thistab$cited))

# nc<-ncol(thistab) #then delete citecount column
# thistab<-thistab[,-nc]

mytab2<-as.matrix(thistab[,2:(nrevs+1)])  #need matrix format for melt


```

```{r domelt}
# Transform the matrix in long format
dfm<- melt(mytab2)
dfm$X1<-thistab[,1] #copies labels into 1st col


colnames(dfm) <- c("x", "Reviewer","value")
dfm$isauthor<-0 #add new column
#we'll now add a column that indicates if Reviewer was an author on that PMID
for (i in 1:nrow(dfm)){
  thisrev<-dfm$Reviewer[i] #this has the short reviewer names from PMID
  thisp <- dfm$x[i]
  plen<-length(thisp)
  s<-unlist(str_split_1(thisp," "))[[1]] #remove stuff after blank to get PMID
  w<-which(dfauth$PMID == s)
  theseauths<-dfauth$Author[w]
  ww<-which(theseauths==thisrev)
  if(length(ww)>0){
  dfm$isauthor[i]<-1
  }

}
  #change isauthor to a colour
dfm$marker<-''
dfm$marker[dfm$isauthor==1]<-'*'

dfm$valuex<-paste0(dfm$value,dfm$marker)

#dfm$Reviewer is a factor.  We should be able to change levels to anonymise
nl<-length(levels(dfm$Reviewer))
levels(dfm$Reviewer) <- c(paste('Reviewer',1:(nl-1)),'Anon')
revlabels<-paste0(levels(dfm$Reviewer)," \n(",revcount[1,]," reviews)")

```



```{r revheatmap}
# Plot heatmap with values -originalwith reviewers on x axis


g <- ggplot(dfm, aes(y = Reviewer, x = x, fill = value, label = marker,color=color)) +
  geom_tile(color = "white") + # Create heatmap
  geom_text(color = "black", size = 3)+ # Add text labels
  scale_fill_gradient(low = "beige", high = "blue") + # Set color gradient
  theme_minimal() + # Set theme
  labs(x = "PMIDs", y = "") + 
 scale_y_discrete(labels=revlabels)+ # Labels
  #theme(legend.position = "none")+
  theme(axis.text.x = element_text(angle = 90, hjust = 1,size=4))+
  theme(axis.text.x = element_text(size=4))

```
